---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by LeeroyLin.
--- DateTime: 2021/7/29 17:27
---

local uiEnum = require('mgrs/ui/ui_enum')
local uiCfg = require('mgrs/ui/ui_cfg')

local uiMgr = {
    isEnable = true,            -- 是否可用

    mainNode = nil,             -- uiCanvas主节点
    uiNode = nil,               -- ui节点
    uiNodeTemplate = nil,       -- ui节点模版
    canvas = nil,               -- uiCanvas
    uiCamera = nil,             -- ui相机
    uiCover = nil,              -- ui遮罩

    sceneNode = nil,            -- sceneCanvas主节点
    sceneCanvas = nil,          -- 场景节点Canvas
    sceneCover = nil,           -- 场景节点遮罩
    sceneCamera = nil,          -- 场景节点相机
    sceneCameraCtrller = nil,   -- 场景节点相机管理器

    cfg = nil,                  -- ui配置信息
    eUI = nil,                  -- ui枚举信息
    eNodes = nil,               -- ui节点枚举

    opQueue = {},               -- 操作队列
    currOp = nil,               -- 当前执行的操作

    uiStack = {},               -- 非Fixed层的ui栈  {ins, key, args}
    uiFixedStack = {},          -- Fixed层的ui栈  {ins, key, args}
    uiSystemStack = {},         -- System层的ui栈  {ins, key, args}
}

-- 操作枚举
local eOp = {
    show = 1,       -- 显示UI
    close = 2,      -- 关闭UI
}

-- 资产条类型
local eProperty = {
    profile = "profile",
    sub = "sub",
}

-- 节点排序
local arrayNodes = {
    uiEnum.eNodes.module,
    uiEnum.eNodes.fixed,
    uiEnum.eNodes.top,
    uiEnum.eNodes.system,
}

-- 节点配置
local nodesCfg = {
    [uiEnum.eNodes.module] = {
        stack = uiMgr.uiStack,         -- 对应的栈
        isAutoClear = true,             -- 是否切场景自动清空
        isTopCheck = true,              -- 是否支持顶层检测
    },
    [uiEnum.eNodes.fixed] = {
        stack = uiMgr.uiFixedStack,    -- 对应的栈
        isAutoClear = false,            -- 是否切场景自动清空
        isTopCheck = false,              -- 是否支持顶层检测
    },
    [uiEnum.eNodes.top] = {
        stack = uiMgr.uiStack,         -- 对应的栈
        isAutoClear = true,             -- 是否切场景自动清空
        isTopCheck = true,              -- 是否支持顶层检测
    },
    [uiEnum.eNodes.system] = {
        stack = uiMgr.uiSystemStack,   -- 对应的栈
        isAutoClear = false,            -- 是否切场景自动清空
        isTopCheck = true,              -- 是否支持顶层检测
    },
}

--- ==================== 其他方法 ====================

--- 执行下一个操作
local function next_op()
    -- 清除当前操作
    uiMgr.currOp = nil

    -- 尝试执行下一个操作
    uiMgr.check_op()
end

--- 获得节点数据
---@param uiKey: UI键
---@return : 对应的节点数据
local function get_node_data(uiKey)
    -- 获得节点及配置
    local node = uiCfg[uiKey].node
    local nodeCfg = nodesCfg[node]

    -- 判空
    if not nodeCfg then
        gError(string.format("[ui_mgr][尝试通过ui '%s' 访问未配置的节点 '%s'.]", uiKey, node))
    end

    return nodeCfg
end

--- 设置遮罩
---@param coverData: 遮罩数据
---@param uiIns: ui实例
---@return : 是否成功设置
local function set_cover(coverData, uiIns)
    -- 是否不显示遮罩
    if not coverData.isHas then
        -- 隐藏
        uiMgr.uiCover.gameObject:SetActive(false)

        -- 没有设置遮罩，遮罩移动到节点外
        uiMgr.uiCover:SetParent(uiMgr.mainNode, false)
        return
    end

    -- 设置遮罩颜色和透明度
    local img = uiMgr.uiCover:GetComponent("Image")
    local color = coverData.color
    color.a = coverData.alpha
    img.color = color

    -- 设置遮罩父节点
    uiMgr.uiCover:SetParent(uiIns.mainNode.parent, false)

    -- 设置遮罩层级
    local idx = uiIns.mainNode:GetSiblingIndex()
    uiMgr.uiCover:SetSiblingIndex(idx)

    -- 设置点击穿透
    img.raycastTarget = not coverData.isClickThrough

    -- 清除按钮事件
    local btn = uiMgr.uiCover:GetComponent("Button")
    btn:ClearEvent()

    -- 是否不可穿透 且 点击关闭
    if not img.raycastTarget and coverData.isClickClose then
        -- 注册新的按钮事件
        btn:AddEvent(function ()
            -- 关闭自身
            uiIns:CloseSelf()
        end)
    end

    -- 显示
    uiMgr.uiCover.gameObject:SetActive(true)

    return true
end

--- 刷新遮罩显示
local function refresh_cover()
    local dicCheck = {}

    -- 反向遍历节点
    for i = #arrayNodes, 1, -1 do
        -- 获得节点及配置
        local eNode = arrayNodes[i]
        local nodeCfg = nodesCfg[eNode]

        -- 是否已经检测过
        if dicCheck[nodeCfg.stack] then

        else
            -- 记录
            dicCheck[nodeCfg.stack] = 1

            -- 反向遍历栈里的ui
            for t = #nodeCfg.stack, 1, -1 do
                -- 获得ui数据
                local uiData = nodeCfg.stack[t]
                local coverData = uiCfg[uiData.key].cover

                -- 是否成功设置遮罩
                if set_cover(coverData, uiData.ins) then
                    return
                end
            end
        end
    end

end

--- 销毁ui资源
local function destroy_res(uiRes)
    for i, res in pairs(uiRes) do
        -- 销毁
        if not gHelper.is_nil(res) then
            gHelper.destroy_node(res)
        end
    end
end

--- 通过数据关闭UI
---@param data: UI数据    {ins, key, args}
---@param stack: UI对应的栈
---@param idx: 下标
local function close_ui_with_data(data, stack, idx)
    -- 反向遍历栈 直到 该ui的下一个
    for i = #stack, idx + 1, -1 do
        -- 获得ui数据
        local uiData = stack[i]
        local uiCfg = uiCfg[uiData.key]

        -- 是否是该ui的子ui
        if uiCfg.parent == data.key then
            -- 递归关闭
            close_ui_with_data(uiData, stack, i)
        end
    end

    -- 回调
    data.ins.isUIClose = true
    data.ins:OnClose()

    -- 销毁资源
    destroy_res(data.ins.uiRes)

    -- 从栈里移除该ui数据
    table.remove(stack, idx)
end

--- 设置资产条
---@param uiData: ui数据
local function set_property_bar(uiData)
    -- 获得配置
    local cfg = uiCfg[uiData.key]

    -- 获得资产条配置
    local cfgProperty = cfg.property
    if cfgProperty then
        local ins = gMgrs.ui.find_ui(gMgrs.ui.eUI.propertyBar).ins

        -- 是否是主界面
        if cfgProperty.type == eProperty.profile then
            -- 显示主界面
            ins:ShowProfileView()
        elseif cfgProperty.type == eProperty.sub then
            local backHandler = nil
            if cfgProperty.backHandler then
                backHandler = function()
                    cfgProperty.backHandler(uiData.key)
                end
            end

            -- 显示子界面
            ins:ShowSubView(cfgProperty.name, backHandler)
        end

        -- 设置资产
        ins:RefreshPropertiesWithCfg(cfgProperty.properties)

        -- 设置充值按钮
        ins:SetBtnRecharge(cfgProperty.btnRecharge)
    end
end

--- 设置主固定UI
---@param uiData: ui数据
local function set_main_fixed_ui(uiData)
    -- 获得配置
    local cfg = uiCfg[uiData.key]

    -- 只有module节点的UI才处理
    if cfg.node ~= gMgrs.ui.eNodes.module then
        return
    end

    -- 设置显隐
    local mainFixedUI = gMgrs.ui.find_ui(gMgrs.ui.eUI.mainFixed)

    if mainFixedUI then

        -- 获得是否显示主固定UI
        local isVisible = cfg.mainFixedUI

        mainFixedUI.ins:SetVisible(isVisible)
    end
end

--- 设置固定UI
local function set_fixed_ui(uiData)
    -- 设置资产条
    set_property_bar(uiData)

    -- 设置主固定UI
    set_main_fixed_ui(uiData)
end

--- 设置可见
---@param stack: UI对应的栈
---@param isCallShow: 是否回调OnShow方法
local function set_visible(stack, isCallShow)
    local cfg = nil

    -- 反向遍历
    for t = #stack, 1, -1 do
        -- 获得ui数据
        local uiData = stack[t]

        -- 是否顶部
        if t == #stack then
            -- 获得配置
            cfg = uiCfg[uiData.key]

            -- 显示
            uiData.ins.mainNode.gameObject:SetActive(true)

            -- 是否回调OnShow方法
            if isCallShow then
                -- 回调Show
                uiData.ins:OnShow()

                -- 设置固定UI
                set_fixed_ui(uiData)
            end

        else
            -- 是否关闭其他
            if cfg.isClearOthers then
                -- 关闭
                close_ui_with_data(uiData, stack, t)

            elseif cfg.isHideOthers then    -- 隐藏
                uiData.ins.mainNode.gameObject:SetActive(false)
            end
        end
    end
end

--- 关闭UI执行方法
---@param opData: 操作数据 {op, key, args}
local function close_ui_handler(opData)
    -- 尝试从栈里获得ui数据
    local uiData, stack, idx = uiMgr.find_ui(opData.key)

    -- 是否之前栈里没有该ui
    if uiData == nil then
        -- 提示
        gError(string.format("[ui_mgr][尝试关闭一个不存在的ui '%s'.]", opData.key))

        -- 执行下一个操作
        next_op()

        return
    end

    -- 关闭该ui
    close_ui_with_data(uiData, stack, idx)

    -- 设置ui可见
    set_visible(stack, true)

    -- 刷新遮罩
    refresh_cover()

    -- 执行下一个操作
    next_op()
end

--- 加载ui资源完毕回调
---@param uiData: ui数据 {ins, key, args}
---@param res: 资源transform数组
local function on_loaded(uiData, res)
    -- 是否UI已经关闭
    if uiData.ins.isUIClose then
        -- 销毁资源
        destroy_res(res)

        -- 执行下一个操作
        next_op()

        return
    end
    
    -- 记录资源
    uiData.ins.uiRes = res
    uiData.ins.mainNode = res[1]

    -- 获得节点
    local nodeName = uiCfg[uiData.key].node
    local uiNode = uiMgr.uiNode:Find(nodeName)

    -- 判空
    if not uiNode then
        gError(string.format("[ui_mgr][尝试访问不存在的ui节点 '%s'.]", nodeName))

        -- 执行下一个操作
        next_op()

        return
    end

    -- 设置ui父节点
    uiData.ins.mainNode:SetParent(uiNode, false)

    -- 获得对应的ui栈
    local stack = get_node_data(uiData.key).stack

    -- 设置ui可见
    set_visible(stack)

    -- 刷新遮罩
    refresh_cover()

    -- 标记没加载
    uiData.ins.isUILoading = false

    -- 关闭顶层遮罩
    gMgrs.cover.hide_cover(gMgrs.cover.eCover.uiLoading)

    -- 设置固定UI
    set_fixed_ui(uiData)

    -- 回调
    uiData.ins:OnGetUIs()
    uiData.ins:OnLoaded()

    -- 执行下一个操作
    next_op()
end

--- 加载ui资源
---@param uiData: ui数据 {ins, key, args}
local function load_resources(uiData)
    -- 获得所有要加载的资源
    local arrayRes = uiData.ins:OnGetUIResources()

    -- 开启顶层遮罩
    gMgrs.cover.show_cover(gMgrs.cover.eCover.uiLoading)

    -- 遍历并异步加载
    local count = 0
    local res = {}
    for i, data in pairs(arrayRes) do
        local t = i
        gMgrs.res.load_asset_async(data.module, data.name, function (obj)
            -- 计次
            count = count + 1

            -- 记录
            res[t] = obj.transform

            -- 是否全部执行完毕
            if count == #arrayRes then
                -- 完毕回调
                on_loaded(uiData, res)
            end
        end)
    end
end

--- 显示UI执行方法
---@param opData: 操作数据 {op, key, args}
local function show_ui_handler(opData)
    -- 尝试从栈里获得ui数据
    local lastUIData, stack, idx = uiMgr.find_ui(opData.key)

    -- 是否之前栈里有该ui了
    if lastUIData ~= nil then
        -- 关闭该ui (包括子ui)
        close_ui_with_data(lastUIData, stack, idx)
    end

    -- 添加新数据
    local data = {
        ins = uiCfg[opData.key].getIns(),  -- 新ui实例
        key = opData.key,
        args = opData.args,
    }
    table.insert(stack, data)

    -- 记录值
    data.ins.uiKey = opData.key
    data.ins.uiArgs = opData.args or {}

    -- 标记在加载
    data.ins.isUILoading = true

    -- 回调
    data.ins:OnInit()

    -- 加载
    gLogGroup(string.format("[ui_mgr][加载ui'%s'资源]", opData.key))
    load_resources(data)
end

--- 执行操作
---@param opData: 操作数据 {op, key, args}
local function execute_op(opData)
    -- 不同操作对应的执行方法
    local switch = {
        [eOp.show] = show_ui_handler,
        [eOp.close] = close_ui_handler,
    }

    -- 调用真正的执行方法
    switch[opData.op](opData)
end

--- 创建ui节点
local function create_nodes()
    -- 遍历节点
    for i, eNode in pairs(arrayNodes) do
        -- 生成空节点
        local node = gUnity.Object.Instantiate(uiMgr.uiNodeTemplate).transform

        -- 设置名字
        node.name = eNode

        -- 显示
        node.gameObject:SetActive(true)

        -- 设置父节点
        node:SetParent(uiMgr.uiNode, false)
    end
end

--- ==================== 公共方法 ====================

--- 初始化
function uiMgr.init()
    -- 获得主节点
    uiMgr.canvas = gUnity.GameObject.Find("UICanvas"):GetComponent("Canvas")
    uiMgr.mainNode = uiMgr.canvas.transform
    uiMgr.uiNode = uiMgr.mainNode:Find("Nodes")
    uiMgr.uiNodeTemplate = uiMgr.uiNode:Find("TempleteNode")
    uiMgr.uiCamera = uiMgr.mainNode:Find("UICamera"):GetComponent("Camera")
    uiMgr.uiCover = uiMgr.mainNode:Find("UICover")

    uiMgr.sceneCanvas = gUnity.GameObject.Find("SceneCanvas"):GetComponent("Canvas")
    local sceneCanvasNode = uiMgr.sceneCanvas.transform
    uiMgr.sceneNode = sceneCanvasNode:Find("Nodes")
    uiMgr.sceneCamera = sceneCanvasNode:Find("SceneCamera"):GetComponent("Camera")
    uiMgr.sceneCameraCtrller = uiMgr.sceneCamera:GetComponent("CameraCtrller")
    uiMgr.sceneCover = sceneCanvasNode:Find("SceneCover")

    -- 获得配置
    uiMgr.cfg = uiCfg

    -- 获得枚举
    uiMgr.eUI = uiEnum.eUI
    uiMgr.eNodes = uiEnum.eNodes

    -- 创建节点
    create_nodes()
end

--- 检测是否有操作需执行
function uiMgr.check_op()
    -- 是否管理器未激活
    if not uiMgr.isEnable then
        return
    end
    
    -- 是否正在操作其他的
    if uiMgr.currOp then
        return
    end

    -- 是否没操作了
    if #uiMgr.opQueue == 0 then
        return
    end

    -- 获取第一个操作并从列表移除
    uiMgr.currOp = table.remove(uiMgr.opQueue, 1)

    -- 执行操作
    execute_op(uiMgr.currOp)
end

--- 显示UI
---@param uiKey: ui键 (ui_mgr.enum 类型)
---@param args: ui参数 （可空）
function uiMgr.show_ui(uiKey, args)
    -- 记录操作到队列里
    table.insert(uiMgr.opQueue, {
        op = eOp.show,
        key = uiKey,
        args = args,
    })

    -- 检测是否有操作需执行
    uiMgr.check_op()
end

--- 关闭UI
---@param uiKey: ui键 (ui_mgr.enum 类型)
function uiMgr.close_ui(uiKey)
    -- 记录操作到队列里
    table.insert(uiMgr.opQueue, {
        op = eOp.close,
        key = uiKey,
        args = nil,
    })

    -- 检测是否有操作需执行
    uiMgr.check_op()
end

--- 设置是否可用
function uiMgr.set_enabled(isEnable)
    -- 标记检测 之前没激活 当前激活
    local isCheck = isEnable and not uiMgr.isEnable

    -- 设置
    uiMgr.isEnable = isEnable

    -- 是否检测
    if isCheck then
        -- 检测
        uiMgr.check_op()
    end
end

--- 获得UI数据
---@param uiKey: ui键 (ui_mgr.enum 类型)
---@return :ui数据，栈, 下标
function uiMgr.find_ui(uiKey)
    -- 获得对应的ui栈
    local stack = get_node_data(uiKey).stack

    -- 遍历栈
    for i, ui_data in pairs(stack) do
        -- ui匹配
        if ui_data.key == uiKey then
            return ui_data, stack, i
        end
    end

    return nil, stack, -1
end

--- 尝试显示UI，如果有了则不显示
---@param uiKey: ui键 (ui_mgr.enum 类型)
---@return: 返回获取到的ui数据
function uiMgr.try_show_ui(uiKey)
    -- 是否没有
    local uiData = gMgrs.ui.find_ui(uiKey)
    if uiData == nil then
        -- 加载资产条
        gMgrs.ui.show_ui(uiKey)
    end

    return uiData
end

--- 获得顶层UI(只检测配置了支持顶层检测的层)
---@param eNode: 节点枚举 空则所有
---@return : 返回顶层UI
function uiMgr.get_top_ui(eNode)
    -- 没有枚举
    if not eNode then
        -- 反向遍历节点
        for i = #arrayNodes, 1, -1 do
            eNode = arrayNodes[i]

            -- 递归
            local res = uiMgr.get_top_ui(eNode)
            if res then
                return res
            end
        end
    else
        local nodeCfg = nodesCfg[eNode]

        -- 是否支持顶层检测
        if nodeCfg.isTopCheck then
            -- 是否有ui
            if #nodeCfg.stack > 0 then
                -- 返回顶层
                return nodeCfg.stack[#nodeCfg.stack]
            end
        end
    end

    return nil
end

--- 检测UI是否是顶层（Fixed节点忽略）
---@param uiKey: ui键 (ui_mgr.enum 类型)
---@return : 返回该UI是否是顶层
function uiMgr.check_is_top(uiKey)
    -- 获得ui配置
    local eNode = uiCfg[uiKey].node

    -- 获得顶部UI
    local topUI = uiMgr.get_top_ui(eNode)
    if topUI then
        return topUI.key == uiKey
    end

    return false
end

--- 自动销毁
---@param isForceClear: 是否强制销毁
function uiMgr.auto_clear(isForceClear)
    local dicStack = {}

    -- 遮罩移动到节点外
    uiMgr.uiCover:SetParent(uiMgr.mainNode, false)

    -- 反向遍历所有节点
    for i = #arrayNodes, 1, -1 do
        -- 获得节点信息
        local eNode = arrayNodes[i]
        local cfg = nodesCfg[eNode]

        -- 是否自动清除
        if isForceClear or cfg.isAutoClear then
            -- 是否没有操作过该栈
            if dicStack[cfg.stack] == nil then
                -- 记录
                dicStack[cfg.stack] = 1

                -- 反向遍历栈
                for t = #cfg.stack, 1, -1 do
                    local data = cfg.stack[t]

                    -- 回调
                    data.ins.isUIClose = true
                    data.ins:OnClose()

                    -- 销毁资源
                    destroy_res(data.ins.uiRes)
                end

                -- 清空栈
                cfg.stack = {}
            end
        end
    end

    -- 清空待执行列表
    uiMgr.opQueue = {}
end

--- 销毁所有UI
function uiMgr.clear_all()
    uiMgr.auto_clear(true)
end

--- 初始化场景相机
function uiMgr.init_scene_camera(boundsObj, size, initPos, callback)
    initPos = initPos or gUnity.Vector2.zero

    uiMgr.sceneCameraCtrller:Init(boundsObj, size, initPos, callback)
end

--- 缩放场景相机
function uiMgr.zoom_scene_camera(size, isAnim)
    uiMgr.sceneCameraCtrller:Zoom(size, isAnim)
end

--- 缩放场景相机位置
function uiMgr.set_scene_camera_pos(pos, isAnim)
    pos = pos or gUnity.Vector2.zero

    uiMgr.sceneCameraCtrller:LookAt(pos, isAnim)
end

--- 缩放场景相机3d位置
function uiMgr.set_scene_camera_3d_pos(pos, isAnim)
    pos = pos or gUnity.Vector3.zero

    uiMgr.sceneCameraCtrller:LookAt3DPos(pos, isAnim)
end

--- 添加场景相机回调
---@param callback: 回调方法 传递一个Bounds类型的参数
---@param interval: 回调间隙
function uiMgr.add_scene_camera_callback(callback, interval)
    uiMgr.sceneCameraCtrller:AddCallback(callback, interval)
end

--- 移除场景相机回调
---@param callback: 回调方法 传递一个Bounds类型的参数
function uiMgr.remove_scene_camera_callback(callback)
    uiMgr.sceneCameraCtrller:RemoveCallback(callback)
end

--- 清除场景相机回调
function uiMgr.clear_scene_camera_callback()
    uiMgr.sceneCameraCtrller:ClearCallback()
end

return uiMgr