---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by LeeroyLin.
--- DateTime: 2021/9/10 12:07
---
local loading_scene = require("loading_scene")

local LOADING_SCENE = "LOADING_SCENE";

local scene_mgr = {}
-- function scene_mgr:open_scene(sceneName,args,finish, progressCallback )
--     gCSharp.OpenScene(sceneName,args,finish, progressCallback)
-- end

function scene_mgr:init()
    self.scene_stack = {}
end


--#region 公有方法

---comment 打开场景，默认loadingscene
function scene_mgr:open_scene(scene_key,param,on_finish,progressCallback)
    local isloading = gSceneCfg[scene_key].isloading or true
    if isloading then
        ---进入loading 场景
        gCSharp.OpenScene(LOADING_SCENE,function()
            self:_loading_to_new_scene(scene_key,param,on_finish,progressCallback)
        end)
    else
       self:_just_load_new_scene(scene_key,param,on_finish,progressCallback)
    end
end

---comment 弹出顶层的场景
function scene_mgr:pop_scene()
    if #self.scene_stack <= 1 then
        return;
    end
    local last_scene_info = self.scene_stack[#self.scene_stack - 1]
    if last_scene_info then
        self:open_scene(last_scene_info.scene_key,last_scene_info.param)
    end
end

---comment 重新加载当前场景
function scene_mgr:reload_cur_scene()
    if #self.scene_stack <= 0 then
        return;
    end
    local last_scene_info = self:_get_last_scene()
    if last_scene_info then
        self:open_scene(last_scene_info.scene_key,last_scene_info.param)
    end
end

--#endregion

--#region 私有方法

---comment 找当前的栈信息，将其剔除掉
---@param scene_key string key
---@return any
---@return any
function scene_mgr:_find_stack(scene_key)
    local stack_scene_info = nil
    local scene_index = nil
    for index = #self.scene_stack,1,-1 do
        local scene_info = self.scene_stack[index]
        if scene_info.scene_key ==scene_key then
            stack_scene_info = scene_info
            scene_index = index;
            break
        end
    end
    return stack_scene_info,scene_index
end

---comment 如果该场景在栈中，则弹出栈
---@param scene_key any
function scene_mgr:_pop_stack(scene_key)
    local scene_info ,scene_index = self:_find_stack()
    if scene_index == nil then
        return
    end
    for index = #self.scene_stack,scene_index,-1 do
        self.scene_stack[#self.scene_stack] = nil
    end
end    

---comment 向栈内压入参数和key
---@param scene_key any
---@param param any
function scene_mgr:_push_stack(scene_key,param,new_scene)
    self.scene_stack[#self.scene_stack+1] = {scene_key = scene_key,param = param,scene = new_scene}
end

---comment 获取当前scene
function scene_mgr:_get_last_scene()
    return self.scene_stack[#self.scene_stack]
end

---comment 在进入loading后，准备进入用户指定的场景
function scene_mgr:_loading_to_new_scene(scene_key,param,on_finish,progressCallback)
    ---生成loading scene
    local loading = loading_scene:new()
    loading:on_loaded()

    ---加载新的场景
    local scene_info = gSceneCfg[scene_key]
    local scene_class = scene_info.scene_class
    local scene_name = scene_info.name
    gCSharp.OpenScene(scene_name,
    ---comment 新场景加载完成回调
    function()
        if on_finish then
            on_finish()
        end

        local old_scene = self:_get_last_scene()
        --由base scene来释放相关资源
        old_scene:_close()
        --由使用者使用的 关闭回调
        old_scene:on_close()

        self:_pop_stack(scene_key)
        local new_scene = scene_class:new()
        self:_push_stack(scene_key,param,new_scene)
        new_scene:_init(scene_key,table.deepcopy(param) )

        new_scene.scene_root = gMgrs.res:load(gEnum.ERes.GameObject,"System","SceneRoot.prefab")
        gMgrs.ui:on_load_new_scene(scene_key,new_scene.scene_root)
        if scene_info.reload_ui then
            gMgrs.ui:reload_scene_ui(function()
                new_scene:on_loaded()
            end)
        else
            new_scene:on_loaded()
        end
    end
    ---comment 更新进度函数
    ,function(value)
        loading:update_prog_value(value)
        if progressCallback then
            progressCallback(value)
        end
    end)
end

---comment 直接进入新场景，不使用loading
---@param scene_key any
---@param param any
---@param on_finish any
---@param progressCallback any
function scene_mgr:_just_load_new_scene(scene_key,param,on_finish,progressCallback)
    local scene_info = gSceneCfg[scene_key]
    local scene_class = scene_info.scene_class
    local scene_name = scene_info.name
    gCSharp.OpenScene(scene_name,
    ---comment 新场景加载完成回调
    function()
        if on_finish then
            on_finish()
        end

        local old_scene = self:_get_last_scene()
        --由base scene来释放相关资源
        old_scene:_close()
        --由使用者使用的 关闭回调
        old_scene:on_close()

        self:_pop_stack(scene_key)
        local new_scene = scene_class:new()
        self:_push_stack(scene_key,param,new_scene)
        new_scene:_init(scene_key,table.deepcopy(param) )
        new_scene.scene_root = gMgrs.res:load(gEnum.ERes.GameObject,"System","SceneRoot.prefab")
        gMgrs.ui:on_load_new_scene(scene_key,new_scene.scene_root)
        if scene_info.reload_ui then
            gMgrs.ui:reload_scene_ui(function()
                new_scene:on_loaded()
            end)
        else
            new_scene:on_loaded()
        end
    end
    ---comment 更新进度函数
    ,function(value)
        if progressCallback then
            progressCallback(value)
        end
    end)
end

--#endregion

return scene_mgr