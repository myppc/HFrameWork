---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by LeeroyLin.
--- DateTime: 2021/8/25 7:38
---

local tcpMgr = require("mgrs/net/tcp/tcp_mgr")
local clsPtcBase = require("mgrs/net/class_ptc_base")
local clsTcpPtc = gClass.declare("clsTcpPtc", clsPtcBase)

--- ==================== 构造方法 ====================

--- 构造方法
---@param ptc: 协议号(发送的协议号 接收的协议号自动+1)
---@param isCache: 是否缓存服务器返回数据(默认不缓存)
---@param handler: 基础回调(可空)
function clsTcpPtc:Ctor(ptc, isCache, handler)
    self.base.Ctor(self, ptc, isCache, handler)

    self.ptcType = "tcp"
    self.isMultiData = false    -- 是否是分段数据
    self.multiKey = nil         -- 分段数据键名
    self.multiFlagOverKey = nil -- 标记结束的键名
    self.multiDic = false       -- 分段数据类型
    self.dicKeyNumber = false   -- 分段数据字典类型下 强转键为number类型
    self.multiData = {}         -- 分段数据
    self.isRecMultiData = false -- 标记是否在接收分段数据中

    -- 注册
    gMgrs.msg.reg(gMgrs.msg.eMsg.net, ptc + 1, function (data) self:OnRecData(data) end)
end

--- ==================== 其他方法 ====================

--- 获取错误码文本
local function get_code_str(code)
    -- todo
    return code
end

--- 接收信息回调
function clsTcpPtc:OnRecData(str)
    -- 解码json
    local data = gJson.decode(str)

    -- 是否有错误码
    if data.content.code ~= nil then
        -- 打印
        gLogGroup("【错误码】", data.content.code)

        -- 提示
        local str = get_code_str(data.content.code)
        gHelper.tips(str)

        -- 回调错误
        self:OnError(str)
    else
        -- 是否分段
        if self.isMultiData then
            -- 添加分段数据
            self:AddMultiData(data.content)
        else
            -- 分发
            self:OnRec(data.content)
        end
    end
end

--- 添加分段数据
function clsTcpPtc:AddMultiData(data)
    -- 是否没有接受分段数据
    if not self.isRecMultiData then
        -- 重置分段数据
        self.multiData = {}

        -- 标记
        self.isRecMultiData = true
    end

    -- 获得数据内容
    local content
    if not string.is_nil(self.multiKey) then
        content = data[self.multiKey]
    else
        content = data
    end

    -- 是否是字典类型
    if self.multiDic then
        -- 遍历数据
        for i, v in pairs(content) do
            -- 是否强转
            if self.dicKeyNumber then
                self.multiData[tonumber(i)] = v
            else
                self.multiData[i] = v
            end
        end
    else    -- 数据类型
        -- 遍历数据
        for i, v in pairs(content) do
            table.insert(self.multiData, v)
        end
    end

    -- 是否分段数据结束
    local flag = data[self.multiFlagOverKey]
    if flag == true or flag == 1 then
        -- 标记
        self.isRecMultiData = false

        -- 分发
        self:OnRec(self.multiData)
    end
end

--- ==================== 公共方法 ====================

--- 发送协议
---@param args: 参数
function clsTcpPtc:Send(args)
    args = args or {}
    tcpMgr.send(tcpMgr.eTcp.logic, self.protocol, args)
end

--- 设置分段数据
---@param multiKey: 分段数据键名 为空时代表根目录
---@param flagOverKey: 标记结束的键名
---@param isDic: 是这是字典类型，否则是数组类型 默认字典
---@param isDicKeyNumber: 是否字典键名强制转number 仅在isDic为true下起效
function clsTcpPtc:SetMultiData(multiKey, flagOverKey, isDic, isDicKeyNumber)
    -- 标记
    self.isMultiData = true

    -- 记录数据
    self.multiKey = multiKey
    self.multiFlagOverKey = flagOverKey
    if isDic == nil then
        isDic = true
    end
    self.multiDic = isDic
    self.dicKeyNumber = isDicKeyNumber
end

return clsTcpPtc