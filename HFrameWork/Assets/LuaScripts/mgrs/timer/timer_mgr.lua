---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by LeeroyLin.
--- DateTime: 2021/9/3 11:49
---

local timerMgr = {
    dicTimer = {
        unscaledTimers = {  -- 不受时间缩放控制的计时器字典
            --[[
            ["key"] = {
                isUnscaled = false,
                callback = nil,
                delay = 0,
                loopInterval = 0,
                loopNum = 0,
                timeCount = 0,      -- 时间计次
                callbackCount = 0,  -- 回调计次
            }
            ]]
        },
        scaledTimers = {  -- 受时间缩放控制的计时器字典

        },
    },
}

--- ==================== 私有方法 ====================

--- 检测是否有下一次循环
---@param data: 计时器数据
local function check_next_loop(data)
    -- 没有循环间隙数据
    if data.loopInterval == nil or data.loopInterval <= 0 then
        return false
    end

    -- 永久循环
    if data.loopNum == nil or data.loopNum <= 0 then
        return true
    end

    -- 次数足够了
    if data.callbackCount > data.loopNum then
        return false
    end

    return true
end

--- 检测计时器
---@param dic: 字典
---@param deltaTime: 时间差
local function check_timer(dic, deltaTime)
    local listRemove = {}
    local listCallback = {} -- 回调列表 {callback, count}

    -- 遍历
    for key, data in pairs(dic) do
        -- 计时
        data.timeCount = data.timeCount + deltaTime

        -- 获取目标时间
        local targetTime = data.delay
        if data.callbackCount > 0 then
            targetTime = data.loopInterval
        end

        -- 是否满足
        while(data.timeCount >= targetTime) do
            -- 减少时间
            data.timeCount = data.timeCount - targetTime

            -- 回调计次
            data.callbackCount = data.callbackCount + 1

            -- 记录到回调列表
            table.insert(listCallback, {
                callback = data.callback,
                count = data.callbackCount
            })

            -- 是否不需回调了
            if not check_next_loop(data) then
                -- 删除数据
                table.insert(listRemove, key)
                break
            end
        end
    end

    -- 遍历删除列表 删除
    for i, v in pairs(listRemove) do
        dic[v] = nil
    end

    -- 回调
    for i, v in pairs(listCallback) do
        v.callback(v.count)
    end
end

--- Update回调
local function on_update()
    -- 检测计时器
    check_timer(timerMgr.dicTimer.scaledTimers, gUnity.Time.deltaTime)
end

--- FixedUpdate回调
local function on_fixed_update()
    -- 检测计时器
    check_timer(timerMgr.dicTimer.unscaledTimers, gUnity.Time.fixedUnscaledDeltaTime)
end

--- 获得对应字典
---@param isUnscaled: 是否不受时间缩放影响
---@return: 对应字典
local function get_dic(isUnscaled)
    local dic = {}
    if isUnscaled then
        dic = timerMgr.dicTimer.unscaledTimers
    else
        dic = timerMgr.dicTimer.scaledTimers
    end

    return dic
end

--- 检测是否有该键名的计时器了
---@param key: 键名
---@return: 是否有，对应字典
local function check_has(key)
    local dic = timerMgr.dicTimer.unscaledTimers

    -- 是否已经有了
    if dic[key] then
        gError(string.format("已经有键名为%s的计时器了", key))
        return true, dic
    end

    dic = timerMgr.dicTimer.scaledTimers

    -- 是否已经有了
    if dic[key] then
        gError(string.format("已经有键名为%s的计时器了", key))
        return true, dic
    end

    return false, nil
end

--- 计时器句柄创建器
---@param key: 键名
---@param dic: 字典
---@return : 计时器句柄
local function timer_creator(key, dic)
    return {
        key = key,
        -- 关闭
        close = function ()
            -- 清除计时器
            timerMgr.clear(key)
        end,
        -- 检测有效
        checkEnabled = function()
            return dic[key] ~= nil
        end,
        -- 立即执行一次
        callNow = function ()
            local data = dic[key]
            if data then
                -- 重置时间
                data.timeCount = 0

                -- 计次并回调
                data.callbackCount = data.callbackCount + 1
                data.callback(data.callbackCount)

                -- 是否不需回调了
                if not check_next_loop(data) then
                    -- 删除数据
                    dic[key] = nil
                end
            end
        end,
    }
end

--- ==================== 公共方法 ====================

--- 初始化
function timerMgr:init()
    -- 注册更新回调
    gMgrs.unityUpdate:reg_update(on_update)
    gMgrs.unityUpdate:reg_fixedupdate(on_fixed_update)
end

--- 使用延迟调用
---@param key: 键名 同时只能存在一个同键名的计时器
---@param isUnscaled: 是否正常时间，即不使用时间缩放
---@param delay: 第一次延迟时间 秒
---@param callback: 回调方法 调用时传递一个参数count，代表回调计次
---@return: 计时器句柄 {key, close, checkEnabled, callNow}
function timerMgr:use(key, isUnscaled, delay, callback)
    -- 判空
    if callback == nil then
        gError("[use] [计时器回调不能为空]")
        return
    end

    -- 延迟不合格
    if delay == nil or delay < 0 then
        gError(string.format("[use_loop] [循环延迟必须非空且大于等于0.当前传入值为:'%s'.]", delay))
        return
    end

    -- 是否已经有了
    if check_has(key) then
        return
    end

    -- 是否立即回调
    if delay == 0 then
        callback(1)
        return
    end

    -- 获得对应字典
    local dic = get_dic(isUnscaled)

    -- 存储
    dic[key] = {
        isUnscaled = isUnscaled,
        callback = callback,
        delay = delay,
        timeCount = 0,
        callbackCount = 0,
    }

    -- 返回句柄
    return timer_creator(key, dic)
end

--- 使用循环延迟调用
---@param key: 键名 同时只能存在一个同键名的计时器
---@param isUnscaled: 是否正常时间，即不使用时间缩放
---@param delay: 第一次延迟时间 秒
---@param loopInterval: 间隙延迟 必须非空且大于0
---@param loopNum: 循环次数 除开第一次的次数 空或小于等于0则永久循环
---@param callback: 回调方法 调用时传递一个参数count，代表回调计次
---@return: 计时器句柄 {key, close, checkEnabled, callNow}
function timerMgr:use_loop(key, isUnscaled, delay, loopInterval, loopNum, callback)
    -- 判空
    if callback == nil then
        gError("[use_loop] [计时器回调不能为空]")
        return
    end

    -- 延迟不合格
    if delay == nil or delay < 0 then
        gError(string.format("[use_loop] [循环延迟必须非空且大于等于0.当前传入值为:'%s'.]", delay))
        return
    end

    -- 循环间隙不合格
    if loopInterval == nil or loopInterval <= 0 then
        gError(string.format("[use_loop] [循环计时器间隙必须非空且大于0.当前传入值为:'%s'.]", loopInterval))
        return
    end

    -- 是否已经有了
    if check_has(key) then
        return
    end

    -- 获得对应字典
    local dic = get_dic(isUnscaled)

    -- 记录
    local data = {
        isUnscaled = isUnscaled,
        callback = callback,
        delay = delay,
        loopInterval = loopInterval,
        loopNum = loopNum,
        timeCount = 0,
        callbackCount = 0,
    }

    -- 是否立即回调一次
    if delay == 0 then
        data.callbackCount = 1
        data.callback(data.callbackCount)
    end

    -- 存储
    dic[key] = data

    -- 返回句柄
    return timer_creator(key, dic)
end

--- 清除计时器
function timerMgr:cancel_by_key(key)
    -- 移除
    timerMgr.dicTimer.scaledTimers[key] = nil
    timerMgr.dicTimer.unscaledTimers[key] = nil
end

--- 清除所有计时器
function timerMgr:clear()
    -- 清空所有数据
    timerMgr.dicTimer.scaledTimers = {}
    timerMgr.dicTimer.unscaledTimers = {}
end

return timerMgr